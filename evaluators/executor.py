#!/usr/bin/env python3
"""
Code Execution Sandbox for LLM-Generated Solutions

Safely executes Python code generated by LLMs and extracts move sequences.
Includes timeout handling, input validation, and output parsing.
"""

import re
import ast
import sys
import io
import time
import signal
from typing import List, Tuple, Any, Optional, Dict, Union
from contextlib import contextmanager, redirect_stdout, redirect_stderr


class TimeoutError(Exception):
    """Raised when code execution times out."""
    pass


class ExecutionError(Exception):
    """Raised when code execution fails."""
    pass


@contextmanager
def timeout(duration: float):
    """Context manager for timeout handling."""
    def timeout_handler(signum, frame):
        raise TimeoutError(f"Execution timed out after {duration} seconds")
    
    # Set up the signal handler
    old_handler = signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(int(duration))
    
    try:
        yield
    finally:
        signal.alarm(0)  # Disable the alarm
        signal.signal(signal.SIGALRM, old_handler)


class CodeExecutor:
    """Safe executor for LLM-generated puzzle solution code."""
    
    def __init__(self, timeout_seconds: float = 10.0):
        """
        Initialize code executor.
        
        Args:
            timeout_seconds: Maximum execution time allowed
        """
        self.timeout_seconds = timeout_seconds
        
        # Allowed built-in functions for safety
        self.safe_builtins = {
            'abs', 'all', 'any', 'bool', 'dict', 'enumerate', 'filter',
            'float', 'int', 'len', 'list', 'map', 'max', 'min', 'range',
            'reversed', 'sorted', 'str', 'sum', 'tuple', 'zip', 'print'
        }
        
        # Restricted imports - only allow safe modules
        self.allowed_modules = {
            'itertools', 'collections', 'functools', 're', 'math'
        }
    
    def extract_code_blocks(self, response: str) -> List[str]:
        """
        Extract Python code blocks from LLM response.
        
        Args:
            response: LLM response text
            
        Returns:
            List of extracted code blocks
        """
        # Pattern to match code blocks
        code_pattern = r'```(?:python)?\s*\n(.*?)\n```'
        code_blocks = re.findall(code_pattern, response, re.DOTALL)
        
        if not code_blocks:
            # Try to find code without triple backticks
            # Look for function definitions or move assignments
            lines = response.split('\n')
            code_lines = []
            in_code = False
            
            for line in lines:
                stripped = line.strip()
                if (stripped.startswith('def ') or 
                    stripped.startswith('moves =') or
                    stripped.startswith('solution =') or
                    in_code):
                    in_code = True
                    code_lines.append(line)
                    # Stop if we hit an empty line after starting code
                    if not stripped and code_lines:
                        break
            
            if code_lines:
                code_blocks = ['\n'.join(code_lines)]
        
        return code_blocks
    
    def validate_code_safety(self, code: str) -> bool:
        """
        Check if code is safe to execute.
        
        Args:
            code: Python code to validate
            
        Returns:
            True if code appears safe, False otherwise
        """
        try:
            tree = ast.parse(code)
        except SyntaxError:
            return False
        
        # Check for dangerous operations
        for node in ast.walk(tree):
            # Block dangerous imports
            if isinstance(node, ast.Import):
                for alias in node.names:
                    if alias.name not in self.allowed_modules:
                        return False
            
            if isinstance(node, ast.ImportFrom):
                if node.module not in self.allowed_modules:
                    return False
            
            # Block dangerous function calls
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Name):
                    # Block dangerous built-ins
                    if node.func.id in ['exec', 'eval', 'open', '__import__', 'compile']:
                        return False
                elif isinstance(node.func, ast.Attribute):
                    # Block dangerous attribute access
                    if node.func.attr in ['system', 'popen', 'remove', 'rmdir']:
                        return False
            
            # Block attribute access to dangerous modules
            if isinstance(node, ast.Attribute):
                if node.attr in ['__globals__', '__locals__', '__dict__', '__code__']:
                    return False
        
        return True
    
    def execute_code(self, code: str, puzzle_input: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute Python code safely and capture outputs.
        
        Args:
            code: Python code to execute
            puzzle_input: Optional puzzle input data to provide to the code
            
        Returns:
            Dictionary with execution results
        """
        if not self.validate_code_safety(code):
            raise ExecutionError("Code contains potentially unsafe operations")
        
        # Prepare execution environment
        # Handle __builtins__ whether it's a dict or module
        if isinstance(__builtins__, dict):
            builtins_source = __builtins__
        else:
            builtins_source = __builtins__.__dict__
        
        exec_globals = {
            '__builtins__': {name: builtins_source[name] 
                           for name in self.safe_builtins 
                           if name in builtins_source}
        }
        
        # Add puzzle input if provided
        if puzzle_input:
            exec_globals.update(puzzle_input)
        
        # Use the same namespace for globals and locals to handle recursive functions
        exec_namespace = exec_globals.copy()
        
        # Capture output
        stdout_capture = io.StringIO()
        stderr_capture = io.StringIO()
        
        result = {
            'success': False,
            'output': '',
            'error': '',
            'moves': None,
            'execution_time': 0
        }
        
        try:
            start_time = time.time()
            
            with timeout(self.timeout_seconds):
                with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
                    exec(code, exec_namespace, exec_namespace)
            
            result['execution_time'] = time.time() - start_time
            result['success'] = True
            result['output'] = stdout_capture.getvalue()
            
            # Try to extract moves from various possible variable names
            possible_move_vars = ['moves', 'solution', 'result', 'answer']
            for var_name in possible_move_vars:
                if var_name in exec_namespace:
                    result['moves'] = exec_namespace[var_name]
                    break
        
        except TimeoutError as e:
            result['error'] = str(e)
        except Exception as e:
            result['error'] = f"Execution error: {str(e)}"
            result['output'] = stdout_capture.getvalue()
        
        # Capture any stderr output
        stderr_output = stderr_capture.getvalue()
        if stderr_output:
            result['error'] = result['error'] + '\n' + stderr_output if result['error'] else stderr_output
        
        return result
    
    def parse_moves_from_output(self, output: str) -> Optional[List[Tuple]]:
        """
        Parse move sequences from captured output.
        
        Args:
            output: Captured stdout from code execution
            
        Returns:
            List of move tuples or None if parsing fails
        """
        # Try to find move lists in the output
        move_patterns = [
            r'\[(.+?)\]',  # List notation
            r'moves\s*=\s*\[(.+?)\]',  # Variable assignment
            r'solution\s*=\s*\[(.+?)\]',  # Solution assignment
        ]
        
        for pattern in move_patterns:
            matches = re.findall(pattern, output, re.DOTALL)
            for match in matches:
                try:
                    # Try to evaluate as Python literal
                    parsed = ast.literal_eval('[' + match + ']')
                    if isinstance(parsed, list) and len(parsed) > 0:
                        return parsed
                except (ValueError, SyntaxError):
                    continue
        
        return None
    
    def extract_moves_from_response(self, response: str, puzzle_input: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Extract move sequences from LLM response by executing any code found.
        
        Args:
            response: LLM response text
            puzzle_input: Optional puzzle input data
            
        Returns:
            Dictionary with extraction results
        """
        result = {
            'success': False,
            'moves': None,
            'execution_results': [],
            'error': ''
        }
        
        # First, try to parse moves directly from response text
        direct_moves = self.parse_moves_from_output(response)
        if direct_moves:
            result['success'] = True
            result['moves'] = direct_moves
            return result
        
        # Extract and execute code blocks
        code_blocks = self.extract_code_blocks(response)
        
        if not code_blocks:
            result['error'] = "No executable code found in response"
            return result
        
        for i, code in enumerate(code_blocks):
            try:
                exec_result = self.execute_code(code, puzzle_input)
                result['execution_results'].append(exec_result)
                
                if exec_result['success']:
                    # Try to get moves from the execution result
                    moves = exec_result.get('moves')
                    if moves:
                        result['success'] = True
                        result['moves'] = moves
                        return result
                    
                    # Try to parse moves from output
                    if exec_result['output']:
                        parsed_moves = self.parse_moves_from_output(exec_result['output'])
                        if parsed_moves:
                            result['success'] = True
                            result['moves'] = parsed_moves
                            return result
                
            except Exception as e:
                result['execution_results'].append({
                    'success': False,
                    'error': f"Failed to execute code block {i}: {str(e)}"
                })
        
        # If we get here, no code block produced valid moves
        if result['execution_results']:
            errors = [r.get('error', '') for r in result['execution_results'] if r.get('error')]
            result['error'] = "Code execution failed: " + '; '.join(errors)
        else:
            result['error'] = "No valid moves extracted from any code block"
        
        return result


def test_executor():
    """Test the code executor with sample inputs."""
    executor = CodeExecutor()
    
    # Test 1: Simple move list
    response1 = """
    Here's the solution:
    ```python
    moves = [("peg_0", "peg_2"), ("peg_0", "peg_1"), ("peg_2", "peg_1")]
    print(moves)
    ```
    """
    
    print("Test 1: Simple move list")
    result1 = executor.extract_moves_from_response(response1)
    print(f"Success: {result1['success']}")
    print(f"Moves: {result1['moves']}")
    print()
    
    # Test 2: Function-based solution
    response2 = """
    Here's a recursive solution:
    ```python
    def solve_hanoi(n, source, dest, aux):
        if n == 1:
            return [(source, dest)]
        else:
            moves = []
            moves.extend(solve_hanoi(n-1, source, aux, dest))
            moves.append((source, dest))
            moves.extend(solve_hanoi(n-1, aux, dest, source))
            return moves
    
    solution = solve_hanoi(3, 'A', 'C', 'B')
    print(solution)
    ```
    """
    
    print("Test 2: Function-based solution")
    result2 = executor.extract_moves_from_response(response2)
    print(f"Success: {result2['success']}")
    print(f"Moves: {result2['moves'][:3] if result2['moves'] else None}...")
    print()
    
    # Test 3: Unsafe code (should fail)
    response3 = """
    ```python
    import os
    os.system("rm -rf /")
    moves = [("a", "b")]
    ```
    """
    
    print("Test 3: Unsafe code")
    result3 = executor.extract_moves_from_response(response3)
    print(f"Success: {result3['success']}")
    print(f"Error: {result3['error']}")


if __name__ == "__main__":
    test_executor() 